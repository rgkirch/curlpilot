#!/bin/bash
#run_tests.bash
set -euo pipefail

source ~/org/.attach/f6/67fc06-5c41-4525-ae0b-e24b1dd67503/scripts/curlpilot/src/profiling/profile.bash

# Get the directory containing this script.
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Define and export a stable path to the BATS libraries.
# This allows test files to safely override PROJECT_ROOT for sandboxing.
export BATS_LIBS_DIR="$SCRIPT_DIR/libs"

# Define the Bats executable path in terms of the libs directory.
BATS_EXECUTABLE="$BATS_LIBS_DIR/bats/bin/bats"

# Initialize variables.
export CURLPILOT_LOG_LEVEL="${CURLPILOT_LOG_LEVEL:-ERROR}"
export CURLPILOT_LOG_LEVEL_BATS="${CURLPILOT_LOG_LEVEL_BATS:-ERROR}"

export BATS_NUMBER_OF_PARALLEL_JOBS=1
BATS_ARGS=()

# Parse arguments to find the --jobs flag and set our environment variable.
# Pass all other arguments through to BATS.
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    -j|--jobs)
      export BATS_NUMBER_OF_PARALLEL_JOBS="$2"
      BATS_ARGS+=("$1" "$2")
      shift 2
      ;;
    --verbose)
      export CURLPILOT_LOG_LEVEL_BATS=INFO
      echo "Log level set to INFO" >&2
      BATS_ARGS+=(--verbose-run)
      shift
      ;;
    --trace)
      export CURLPILOT_TRACE=true
      echo "Tracing enabled." >&2
      BATS_ARGS+=(--no-tempdir-cleanup)
      shift # Consume the --trace flag, do not pass it to BATS.
      ;;
    *)
      BATS_ARGS+=("$1")
      shift
      ;;
  esac
done

# Check if the Bats executable exists.
if [ ! -x "$BATS_EXECUTABLE" ]; then
  echo "Bats executable not found or not executable: $BATS_EXECUTABLE"
  exit 1
fi

: "${BATS_RUN_TMPDIR:="$(mktemp -du)"}"

echo "Running command: '$BATS_EXECUTABLE' --timing '${BATS_ARGS[*]}'"
"$BATS_EXECUTABLE" --timing "${BATS_ARGS[@]}" --tempdir "$BATS_RUN_TMPDIR"


# If tracing is enabled, run post-processing scripts to generate analysis files.
if [[ "${CURLPILOT_TRACE:-}" == "true" ]]; then
  echo "Processing trace data..." >&2

  # Source the helper scripts using an absolute path derived from the script's location.
  if [[ -f "$SCRIPT_DIR/src/tracing/collapsed_stack.bash" ]]; then
    source "$SCRIPT_DIR/src/tracing/collapsed_stack.bash"
  fi
  if [[ -f "$SCRIPT_DIR/src/tracing/trace_event.bash" ]]; then
    source "$SCRIPT_DIR/src/tracing/trace_event.bash"
  fi

  # Find all trace root directories generated by the BATS run.
  while IFS= read -r trace_root; do
    [[ -z "$trace_root" ]] && continue

    # Generate collapsed stack files if the function exists.
    if command -v gemini_collapsed_stack_from_trace_root &> /dev/null; then
      echo "  Generating collapsed stack files in $trace_root" >&2
      gemini_collapsed_stack_from_trace_root "$trace_root" wall > "$trace_root/collapsed-stacks-wall.txt" || true
      gemini_collapsed_stack_from_trace_root "$trace_root" cpu > "$trace_root/collapsed-stacks-cpu.txt" || true
    else
      echo "  WARNING: gemini_collapsed_stack_from_trace_root function not found. Skipping." >&2
    fi

    # Generate the Trace Event Format JSON file if the function exists.
    if command -v trace_event_from_trace_root &> /dev/null; then
      output_file="$trace_root/trace.json"
      echo "  Generating Trace Event file: $output_file" >&2
      trace_event_from_trace_root "$trace_root" > "$output_file" || true
      echo "    -> To view, open the file at https://ui.perfetto.dev/" >&2
    else
      echo "  WARNING: trace_event_from_trace_root function not found. Skipping." >&2
    fi

  done < <(find "$BATS_RUN_TMPDIR" -type f -name .suite_id -printf '%h\n')
fi
